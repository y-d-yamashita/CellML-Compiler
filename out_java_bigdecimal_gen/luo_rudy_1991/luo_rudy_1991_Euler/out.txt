import java.math.BigDecimal;
import java.math.BigInteger;
import java.math.MathContext;
import java.math.RoundingMode;


public final class JavaBigDecimalProgram{
public static void main ( String args[] ) {

	int __i;
	BigDecimal xi[];
	BigDecimal xo[];
	BigDecimal x1[];
	BigDecimal x2[];
	BigDecimal k1[];
	BigDecimal y1[];
	BigDecimal z[];
	BigDecimal t;
	BigDecimal d = new BigDecimal( 0.010000);
	int __DATA_NUM = 32;
	int __SCALE = 80;

	xi = new BigDecimal[ ( 8 * __DATA_NUM ) ];
	xo = new BigDecimal[ ( 8 * __DATA_NUM ) ];
	x1 = new BigDecimal[ ( 8 * __DATA_NUM ) ];
	x2 = new BigDecimal[ ( 8 * __DATA_NUM ) ];
	y1 = new BigDecimal[ ( 31 * __DATA_NUM ) ];
	k1 = new BigDecimal[ ( 8 * __DATA_NUM ) ];
	z = new BigDecimal[18];
	for(t = new BigDecimal(0.000000); ( t.compareTo(new BigDecimal(400.000000))<=0) ;t =  ( t .add( d) ) ){

		for(__i = 0; ( __i < __DATA_NUM ) ;__i++){

			x1[ (  ( 0 * __DATA_NUM )  + __i ) ] = xi[ (  ( 0 * __DATA_NUM )  + __i ) ];
			x1[ (  ( 1 * __DATA_NUM )  + __i ) ] = xi[ (  ( 1 * __DATA_NUM )  + __i ) ];
			x1[ (  ( 2 * __DATA_NUM )  + __i ) ] = xi[ (  ( 2 * __DATA_NUM )  + __i ) ];
			x1[ (  ( 3 * __DATA_NUM )  + __i ) ] = xi[ (  ( 3 * __DATA_NUM )  + __i ) ];
			x1[ (  ( 4 * __DATA_NUM )  + __i ) ] = xi[ (  ( 4 * __DATA_NUM )  + __i ) ];
			x1[ (  ( 5 * __DATA_NUM )  + __i ) ] = xi[ (  ( 5 * __DATA_NUM )  + __i ) ];
			x1[ (  ( 6 * __DATA_NUM )  + __i ) ] = xi[ (  ( 6 * __DATA_NUM )  + __i ) ];
			x1[ (  ( 7 * __DATA_NUM )  + __i ) ] = xi[ (  ( 7 * __DATA_NUM )  + __i ) ];
			y1[ (  ( 0 * __DATA_NUM )  + __i ) ] =  (  (  ( t .compareTo(z[4])>=0)  &&  ( t.compareTo(z[5])<=0)  &&  (  (  ( t.subtract(z[4])) .subtract( ( ((   ( t.subtract(z[4])) .divide(z[6] ,128,BigDecimal.ROUND_HALF_UP) ).setScale(0,RoundingMode.FLOOR)).multiply(z[6], MathContext.DECIMAL128) ) )) .compareTo(z[7])<=0)  )  ? z[8] : new BigDecimal(0) ) ;
			y1[ (  ( 1 * __DATA_NUM )  + __i ) ] =    ( new BigDecimal(0.32).multiply( ( x1[ (  ( 0 * __DATA_NUM )  + __i ) ].add(new BigDecimal(47.13)) ) , MathContext.DECIMAL128) ) .divide( ( new BigDecimal(1).subtract(exp( (  (new BigDecimal(-0.1)) .multiply( ( x1[ (  ( 0 * __DATA_NUM )  + __i ) ].add(new BigDecimal(47.13)) ) , MathContext.DECIMAL128) ) ,__SCALE)))  ,128,BigDecimal.ROUND_HALF_UP) ;
			y1[ (  ( 2 * __DATA_NUM )  + __i ) ] =  (  ( x1[ (  ( 0 * __DATA_NUM )  + __i ) ] .compareTo( (new BigDecimal(-40)) )<0)  ?  ( new BigDecimal(0.135).multiply(exp(   ( new BigDecimal(80) .add( x1[ (  ( 0 * __DATA_NUM )  + __i ) ]) ) .divide( (new BigDecimal(-6.8))  ,128,BigDecimal.ROUND_HALF_UP) ,__SCALE), MathContext.DECIMAL128) )  : new BigDecimal(0) ) ;
			y1[ (  ( 3 * __DATA_NUM )  + __i ) ] =  (  ( x1[ (  ( 0 * __DATA_NUM )  + __i ) ] .compareTo( (new BigDecimal(-40)) )<0)  ?    (  (  (  (new BigDecimal(-127140)) .multiply(exp( ( new BigDecimal(0.2444).multiply(x1[ (  ( 0 * __DATA_NUM )  + __i ) ], MathContext.DECIMAL128) ) ,__SCALE), MathContext.DECIMAL128) ) .subtract( ( new BigDecimal(0.00003474).multiply(exp( (  (new BigDecimal(-0.04391)) .multiply(x1[ (  ( 0 * __DATA_NUM )  + __i ) ], MathContext.DECIMAL128) ) ,__SCALE), MathContext.DECIMAL128) ) )) .multiply( ( x1[ (  ( 0 * __DATA_NUM )  + __i ) ].add(new BigDecimal(37.78)) ) , MathContext.DECIMAL128) ) .divide( ( new BigDecimal(1).add(exp( ( new BigDecimal(0.311).multiply( ( x1[ (  ( 0 * __DATA_NUM )  + __i ) ].add(new BigDecimal(79.23)) ) , MathContext.DECIMAL128) ) ,__SCALE)) )  ,128,BigDecimal.ROUND_HALF_UP)  : new BigDecimal(0) ) ;
			y1[ (  ( 4 * __DATA_NUM )  + __i ) ] =  ( new BigDecimal(7.7).subtract( ( new BigDecimal(13.0287).multiply(ln(   x1[ (  ( 7 * __DATA_NUM )  + __i ) ].divide(new BigDecimal(1) ,128,BigDecimal.ROUND_HALF_UP)  ,__SCALE), MathContext.DECIMAL128) ) )) ;
			y1[ (  ( 5 * __DATA_NUM )  + __i ) ] =    ( new BigDecimal(0.095).multiply(exp( (  (new BigDecimal(-0.01)) .multiply( ( x1[ (  ( 0 * __DATA_NUM )  + __i ) ].subtract(new BigDecimal(5))) , MathContext.DECIMAL128) ) ,__SCALE), MathContext.DECIMAL128) ) .divide( ( new BigDecimal(1).add(exp( (  (new BigDecimal(-0.072)) .multiply( ( x1[ (  ( 0 * __DATA_NUM )  + __i ) ].subtract(new BigDecimal(5))) , MathContext.DECIMAL128) ) ,__SCALE)) )  ,128,BigDecimal.ROUND_HALF_UP) ;
			y1[ (  ( 6 * __DATA_NUM )  + __i ) ] =    ( new BigDecimal(0.012).multiply(exp( (  (new BigDecimal(-0.008)) .multiply( ( x1[ (  ( 0 * __DATA_NUM )  + __i ) ].add(new BigDecimal(28)) ) , MathContext.DECIMAL128) ) ,__SCALE), MathContext.DECIMAL128) ) .divide( ( new BigDecimal(1).add(exp( ( new BigDecimal(0.15).multiply( ( x1[ (  ( 0 * __DATA_NUM )  + __i ) ].add(new BigDecimal(28)) ) , MathContext.DECIMAL128) ) ,__SCALE)) )  ,128,BigDecimal.ROUND_HALF_UP) ;
			y1[ (  ( 7 * __DATA_NUM )  + __i ) ] =  ( new BigDecimal(0.282).multiply(sqrt(   z[13].divide(new BigDecimal(5.4) ,128,BigDecimal.ROUND_HALF_UP)  ,__SCALE), MathContext.DECIMAL128) ) ;
			y1[ (  ( 8 * __DATA_NUM )  + __i ) ] =    ( new BigDecimal(0.0005).multiply(exp( ( new BigDecimal(0.083).multiply( ( x1[ (  ( 0 * __DATA_NUM )  + __i ) ].add(new BigDecimal(50)) ) , MathContext.DECIMAL128) ) ,__SCALE), MathContext.DECIMAL128) ) .divide( ( new BigDecimal(1).add(exp( ( new BigDecimal(0.057).multiply( ( x1[ (  ( 0 * __DATA_NUM )  + __i ) ].add(new BigDecimal(50)) ) , MathContext.DECIMAL128) ) ,__SCALE)) )  ,128,BigDecimal.ROUND_HALF_UP) ;
			y1[ (  ( 9 * __DATA_NUM )  + __i ) ] =  (  ( x1[ (  ( 0 * __DATA_NUM )  + __i ) ] .compareTo( (new BigDecimal(-100)) )>0)  ?    ( new BigDecimal(2.837).multiply( ( exp( ( new BigDecimal(0.04).multiply( ( x1[ (  ( 0 * __DATA_NUM )  + __i ) ].add(new BigDecimal(77)) ) , MathContext.DECIMAL128) ) ,__SCALE).subtract(new BigDecimal(1))) , MathContext.DECIMAL128) ) .divide( (  ( x1[ (  ( 0 * __DATA_NUM )  + __i ) ].add(new BigDecimal(77)) ) .multiply(exp( ( new BigDecimal(0.04).multiply( ( x1[ (  ( 0 * __DATA_NUM )  + __i ) ].add(new BigDecimal(35)) ) , MathContext.DECIMAL128) ) ,__SCALE), MathContext.DECIMAL128) )  ,128,BigDecimal.ROUND_HALF_UP)  : new BigDecimal(1) ) ;
			y1[ (  ( 10 * __DATA_NUM )  + __i ) ] =  (    ( z[0].multiply(z[1], MathContext.DECIMAL128) ) .divide(z[2] ,128,BigDecimal.ROUND_HALF_UP) .multiply(ln(   z[13].divide(z[14] ,128,BigDecimal.ROUND_HALF_UP)  ,__SCALE), MathContext.DECIMAL128) ) ;
			y1[ (  ( 11 * __DATA_NUM )  + __i ) ] =   new BigDecimal(1.02).divide( ( new BigDecimal(1).add(exp( ( new BigDecimal(0.2385).multiply( (  ( x1[ (  ( 0 * __DATA_NUM )  + __i ) ].subtract(y1[ (  ( 10 * __DATA_NUM )  + __i ) ])) .subtract(new BigDecimal(59.215))) , MathContext.DECIMAL128) ) ,__SCALE)) )  ,128,BigDecimal.ROUND_HALF_UP) ;
			y1[ (  ( 12 * __DATA_NUM )  + __i ) ] = y1[ (  ( 10 * __DATA_NUM )  + __i ) ];
			y1[ (  ( 13 * __DATA_NUM )  + __i ) ] =  ( z[17].multiply( ( x1[ (  ( 0 * __DATA_NUM )  + __i ) ].subtract(z[16])) , MathContext.DECIMAL128) ) ;
			y1[ (  ( 14 * __DATA_NUM )  + __i ) ] =  (    ( z[0].multiply(z[1], MathContext.DECIMAL128) ) .divide(z[2] ,128,BigDecimal.ROUND_HALF_UP) .multiply(ln(   z[10].divide(z[11] ,128,BigDecimal.ROUND_HALF_UP)  ,__SCALE), MathContext.DECIMAL128) ) ;
			y1[ (  ( 15 * __DATA_NUM )  + __i ) ] =  ( new BigDecimal(0.08).multiply(exp(  (x1[ (  ( 0 * __DATA_NUM )  + __i ) ]).negate() .divide(new BigDecimal(11) ,128,BigDecimal.ROUND_HALF_UP) ,__SCALE), MathContext.DECIMAL128) ) ;
			y1[ (  ( 16 * __DATA_NUM )  + __i ) ] =  (  ( x1[ (  ( 0 * __DATA_NUM )  + __i ) ] .compareTo( (new BigDecimal(-40)) )<0)  ?    ( new BigDecimal(0.1212).multiply(exp( (  (new BigDecimal(-0.01052)) .multiply(x1[ (  ( 0 * __DATA_NUM )  + __i ) ], MathContext.DECIMAL128) ) ,__SCALE), MathContext.DECIMAL128) ) .divide( ( new BigDecimal(1).add(exp( (  (new BigDecimal(-0.1378)) .multiply( ( x1[ (  ( 0 * __DATA_NUM )  + __i ) ].add(new BigDecimal(40.14)) ) , MathContext.DECIMAL128) ) ,__SCALE)) )  ,128,BigDecimal.ROUND_HALF_UP)  :    ( new BigDecimal(0.3).multiply(exp( (  (new BigDecimal(-0.0000002535)) .multiply(x1[ (  ( 0 * __DATA_NUM )  + __i ) ], MathContext.DECIMAL128) ) ,__SCALE), MathContext.DECIMAL128) ) .divide( ( new BigDecimal(1).add(exp( (  (new BigDecimal(-0.1)) .multiply( ( x1[ (  ( 0 * __DATA_NUM )  + __i ) ].add(new BigDecimal(32)) ) , MathContext.DECIMAL128) ) ,__SCALE)) )  ,128,BigDecimal.ROUND_HALF_UP)  ) ;
			y1[ (  ( 17 * __DATA_NUM )  + __i ) ] =    ( new BigDecimal(0.07).multiply(exp( (  (new BigDecimal(-0.017)) .multiply( ( x1[ (  ( 0 * __DATA_NUM )  + __i ) ].add(new BigDecimal(44)) ) , MathContext.DECIMAL128) ) ,__SCALE), MathContext.DECIMAL128) ) .divide( ( new BigDecimal(1).add(exp( ( new BigDecimal(0.05).multiply( ( x1[ (  ( 0 * __DATA_NUM )  + __i ) ].add(new BigDecimal(44)) ) , MathContext.DECIMAL128) ) ,__SCALE)) )  ,128,BigDecimal.ROUND_HALF_UP) ;
			y1[ (  ( 18 * __DATA_NUM )  + __i ) ] =  (    ( z[0].multiply(z[1], MathContext.DECIMAL128) ) .divide(z[2] ,128,BigDecimal.ROUND_HALF_UP) .multiply(ln(    ( z[13].add( ( z[12].multiply(z[10], MathContext.DECIMAL128) ) ) ) .divide( ( z[14].add( ( z[12].multiply(z[11], MathContext.DECIMAL128) ) ) )  ,128,BigDecimal.ROUND_HALF_UP)  ,__SCALE), MathContext.DECIMAL128) ) ;
			y1[ (  ( 19 * __DATA_NUM )  + __i ) ] =    ( new BigDecimal(0.0013).multiply(exp( (  (new BigDecimal(-0.06)) .multiply( ( x1[ (  ( 0 * __DATA_NUM )  + __i ) ].add(new BigDecimal(20)) ) , MathContext.DECIMAL128) ) ,__SCALE), MathContext.DECIMAL128) ) .divide( ( new BigDecimal(1).add(exp( (  (new BigDecimal(-0.04)) .multiply( ( x1[ (  ( 0 * __DATA_NUM )  + __i ) ].add(new BigDecimal(20)) ) , MathContext.DECIMAL128) ) ,__SCALE)) )  ,128,BigDecimal.ROUND_HALF_UP) ;
			y1[ (  ( 20 * __DATA_NUM )  + __i ) ] =    (  ( new BigDecimal(0.49124).multiply(exp( ( new BigDecimal(0.08032).multiply( (  ( x1[ (  ( 0 * __DATA_NUM )  + __i ) ].add(new BigDecimal(5.476)) ) .subtract(y1[ (  ( 10 * __DATA_NUM )  + __i ) ])) , MathContext.DECIMAL128) ) ,__SCALE), MathContext.DECIMAL128) ) .add( ( new BigDecimal(1).multiply(exp( ( new BigDecimal(0.06175).multiply( ( x1[ (  ( 0 * __DATA_NUM )  + __i ) ].subtract( ( y1[ (  ( 10 * __DATA_NUM )  + __i ) ].add(new BigDecimal(594.31)) ) )) , MathContext.DECIMAL128) ) ,__SCALE), MathContext.DECIMAL128) ) ) ) .divide( ( new BigDecimal(1).add(exp( (  (new BigDecimal(-0.5143)) .multiply( (  ( x1[ (  ( 0 * __DATA_NUM )  + __i ) ].subtract(y1[ (  ( 10 * __DATA_NUM )  + __i ) ])) .add(new BigDecimal(4.753)) ) , MathContext.DECIMAL128) ) ,__SCALE)) )  ,128,BigDecimal.ROUND_HALF_UP) ;
			y1[ (  ( 21 * __DATA_NUM )  + __i ) ] =   new BigDecimal(1).divide( ( new BigDecimal(1).add(exp(   ( new BigDecimal(7.488).subtract(x1[ (  ( 0 * __DATA_NUM )  + __i ) ])) .divide(new BigDecimal(5.98) ,128,BigDecimal.ROUND_HALF_UP) ,__SCALE)) )  ,128,BigDecimal.ROUND_HALF_UP) ;
			y1[ (  ( 22 * __DATA_NUM )  + __i ) ] =  ( z[9].multiply((x1[ (  ( 1 * __DATA_NUM )  + __i ) ].pow(3 )), MathContext.DECIMAL128).multiply(x1[ (  ( 2 * __DATA_NUM )  + __i ) ], MathContext.DECIMAL128).multiply(x1[ (  ( 3 * __DATA_NUM )  + __i ) ], MathContext.DECIMAL128).multiply( ( x1[ (  ( 0 * __DATA_NUM )  + __i ) ].subtract(y1[ (  ( 14 * __DATA_NUM )  + __i ) ])) , MathContext.DECIMAL128) ) ;
			y1[ (  ( 23 * __DATA_NUM )  + __i ) ] =  ( new BigDecimal(0.09).multiply(x1[ (  ( 4 * __DATA_NUM )  + __i ) ], MathContext.DECIMAL128).multiply(x1[ (  ( 5 * __DATA_NUM )  + __i ) ], MathContext.DECIMAL128).multiply( ( x1[ (  ( 0 * __DATA_NUM )  + __i ) ].subtract(y1[ (  ( 4 * __DATA_NUM )  + __i ) ])) , MathContext.DECIMAL128) ) ;
			y1[ (  ( 24 * __DATA_NUM )  + __i ) ] =  ( y1[ (  ( 7 * __DATA_NUM )  + __i ) ].multiply(x1[ (  ( 6 * __DATA_NUM )  + __i ) ], MathContext.DECIMAL128).multiply(y1[ (  ( 9 * __DATA_NUM )  + __i ) ], MathContext.DECIMAL128).multiply( ( x1[ (  ( 0 * __DATA_NUM )  + __i ) ].subtract(y1[ (  ( 18 * __DATA_NUM )  + __i ) ])) , MathContext.DECIMAL128) ) ;
			y1[ (  ( 25 * __DATA_NUM )  + __i ) ] =   y1[ (  ( 11 * __DATA_NUM )  + __i ) ].divide( ( y1[ (  ( 11 * __DATA_NUM )  + __i ) ] .add( y1[ (  ( 20 * __DATA_NUM )  + __i ) ]) )  ,128,BigDecimal.ROUND_HALF_UP) ;
			y1[ (  ( 26 * __DATA_NUM )  + __i ) ] =  (  ( x1[ (  ( 0 * __DATA_NUM )  + __i ) ] .compareTo( (new BigDecimal(-40)) )<0)  ?  (  ( new BigDecimal(3.56).multiply(exp( ( new BigDecimal(0.079).multiply(x1[ (  ( 0 * __DATA_NUM )  + __i ) ], MathContext.DECIMAL128) ) ,__SCALE), MathContext.DECIMAL128) ) .add( ( new BigDecimal(310000).multiply(exp( ( new BigDecimal(0.35).multiply(x1[ (  ( 0 * __DATA_NUM )  + __i ) ], MathContext.DECIMAL128) ) ,__SCALE), MathContext.DECIMAL128) ) ) )  :   new BigDecimal(1).divide( ( new BigDecimal(0.13).multiply( ( new BigDecimal(1).add(exp(   ( x1[ (  ( 0 * __DATA_NUM )  + __i ) ].add(new BigDecimal(10.66)) ) .divide( (new BigDecimal(-11.1))  ,128,BigDecimal.ROUND_HALF_UP) ,__SCALE)) ) , MathContext.DECIMAL128) )  ,128,BigDecimal.ROUND_HALF_UP)  ) ;
			y1[ (  ( 27 * __DATA_NUM )  + __i ) ] =  ( new BigDecimal(0.6047).multiply(sqrt(   z[13].divide(new BigDecimal(5.4) ,128,BigDecimal.ROUND_HALF_UP)  ,__SCALE), MathContext.DECIMAL128) ) ;
			y1[ (  ( 28 * __DATA_NUM )  + __i ) ] =  ( z[15].multiply(y1[ (  ( 21 * __DATA_NUM )  + __i ) ], MathContext.DECIMAL128).multiply( ( x1[ (  ( 0 * __DATA_NUM )  + __i ) ].subtract(y1[ (  ( 12 * __DATA_NUM )  + __i ) ])) , MathContext.DECIMAL128) ) ;
			y1[ (  ( 29 * __DATA_NUM )  + __i ) ] =    ( new BigDecimal(0.0065).multiply(exp( (  (new BigDecimal(-0.02)) .multiply( ( x1[ (  ( 0 * __DATA_NUM )  + __i ) ].add(new BigDecimal(30)) ) , MathContext.DECIMAL128) ) ,__SCALE), MathContext.DECIMAL128) ) .divide( ( new BigDecimal(1).add(exp( (  (new BigDecimal(-0.2)) .multiply( ( x1[ (  ( 0 * __DATA_NUM )  + __i ) ].add(new BigDecimal(30)) ) , MathContext.DECIMAL128) ) ,__SCALE)) )  ,128,BigDecimal.ROUND_HALF_UP) ;
			y1[ (  ( 30 * __DATA_NUM )  + __i ) ] =  ( y1[ (  ( 27 * __DATA_NUM )  + __i ) ].multiply(y1[ (  ( 25 * __DATA_NUM )  + __i ) ], MathContext.DECIMAL128).multiply( ( x1[ (  ( 0 * __DATA_NUM )  + __i ) ].subtract(y1[ (  ( 10 * __DATA_NUM )  + __i ) ])) , MathContext.DECIMAL128) ) ;
			k1[ (  ( 0 * __DATA_NUM )  + __i ) ] =  (    (new BigDecimal(-1)) .divide(z[3] ,128,BigDecimal.ROUND_HALF_UP) .multiply( ( y1[ (  ( 0 * __DATA_NUM )  + __i ) ] .add( y1[ (  ( 22 * __DATA_NUM )  + __i ) ]) .add( y1[ (  ( 23 * __DATA_NUM )  + __i ) ]) .add( y1[ (  ( 24 * __DATA_NUM )  + __i ) ]) .add( y1[ (  ( 30 * __DATA_NUM )  + __i ) ]) .add( y1[ (  ( 28 * __DATA_NUM )  + __i ) ]) .add( y1[ (  ( 13 * __DATA_NUM )  + __i ) ]) ) , MathContext.DECIMAL128) ) ;
			k1[ (  ( 1 * __DATA_NUM )  + __i ) ] =  (  ( y1[ (  ( 1 * __DATA_NUM )  + __i ) ].multiply( ( new BigDecimal(1).subtract(x1[ (  ( 1 * __DATA_NUM )  + __i ) ])) , MathContext.DECIMAL128) ) .subtract( ( y1[ (  ( 15 * __DATA_NUM )  + __i ) ].multiply(x1[ (  ( 1 * __DATA_NUM )  + __i ) ], MathContext.DECIMAL128) ) )) ;
			k1[ (  ( 2 * __DATA_NUM )  + __i ) ] =  (  ( y1[ (  ( 2 * __DATA_NUM )  + __i ) ].multiply( ( new BigDecimal(1).subtract(x1[ (  ( 2 * __DATA_NUM )  + __i ) ])) , MathContext.DECIMAL128) ) .subtract( ( y1[ (  ( 26 * __DATA_NUM )  + __i ) ].multiply(x1[ (  ( 2 * __DATA_NUM )  + __i ) ], MathContext.DECIMAL128) ) )) ;
			k1[ (  ( 3 * __DATA_NUM )  + __i ) ] =  (  ( y1[ (  ( 3 * __DATA_NUM )  + __i ) ].multiply( ( new BigDecimal(1).subtract(x1[ (  ( 3 * __DATA_NUM )  + __i ) ])) , MathContext.DECIMAL128) ) .subtract( ( y1[ (  ( 16 * __DATA_NUM )  + __i ) ].multiply(x1[ (  ( 3 * __DATA_NUM )  + __i ) ], MathContext.DECIMAL128) ) )) ;
			k1[ (  ( 4 * __DATA_NUM )  + __i ) ] =  (  ( y1[ (  ( 5 * __DATA_NUM )  + __i ) ].multiply( ( new BigDecimal(1).subtract(x1[ (  ( 4 * __DATA_NUM )  + __i ) ])) , MathContext.DECIMAL128) ) .subtract( ( y1[ (  ( 17 * __DATA_NUM )  + __i ) ].multiply(x1[ (  ( 4 * __DATA_NUM )  + __i ) ], MathContext.DECIMAL128) ) )) ;
			k1[ (  ( 5 * __DATA_NUM )  + __i ) ] =  (  ( y1[ (  ( 6 * __DATA_NUM )  + __i ) ].multiply( ( new BigDecimal(1).subtract(x1[ (  ( 5 * __DATA_NUM )  + __i ) ])) , MathContext.DECIMAL128) ) .subtract( ( y1[ (  ( 29 * __DATA_NUM )  + __i ) ].multiply(x1[ (  ( 5 * __DATA_NUM )  + __i ) ], MathContext.DECIMAL128) ) )) ;
			k1[ (  ( 6 * __DATA_NUM )  + __i ) ] =  (  ( y1[ (  ( 8 * __DATA_NUM )  + __i ) ].multiply( ( new BigDecimal(1).subtract(x1[ (  ( 6 * __DATA_NUM )  + __i ) ])) , MathContext.DECIMAL128) ) .subtract( ( y1[ (  ( 19 * __DATA_NUM )  + __i ) ].multiply(x1[ (  ( 6 * __DATA_NUM )  + __i ) ], MathContext.DECIMAL128) ) )) ;
			k1[ (  ( 7 * __DATA_NUM )  + __i ) ] =  (  (    (new BigDecimal(-0.0001)) .divide(new BigDecimal(1) ,128,BigDecimal.ROUND_HALF_UP) .multiply(y1[ (  ( 23 * __DATA_NUM )  + __i ) ], MathContext.DECIMAL128) ) .add( ( new BigDecimal(0.07).multiply( ( new BigDecimal(0.0001).subtract(x1[ (  ( 7 * __DATA_NUM )  + __i ) ])) , MathContext.DECIMAL128) ) ) ) ;
			x2[ (  ( 0 * __DATA_NUM )  + __i ) ] =  ( x1[ (  ( 0 * __DATA_NUM )  + __i ) ].add( ( k1[ (  ( 0 * __DATA_NUM )  + __i ) ].multiply(d, MathContext.DECIMAL128) ) ) ) ;
			x2[ (  ( 1 * __DATA_NUM )  + __i ) ] =  ( x1[ (  ( 1 * __DATA_NUM )  + __i ) ].add( ( k1[ (  ( 1 * __DATA_NUM )  + __i ) ].multiply(d, MathContext.DECIMAL128) ) ) ) ;
			x2[ (  ( 2 * __DATA_NUM )  + __i ) ] =  ( x1[ (  ( 2 * __DATA_NUM )  + __i ) ].add( ( k1[ (  ( 2 * __DATA_NUM )  + __i ) ].multiply(d, MathContext.DECIMAL128) ) ) ) ;
			x2[ (  ( 3 * __DATA_NUM )  + __i ) ] =  ( x1[ (  ( 3 * __DATA_NUM )  + __i ) ].add( ( k1[ (  ( 3 * __DATA_NUM )  + __i ) ].multiply(d, MathContext.DECIMAL128) ) ) ) ;
			x2[ (  ( 4 * __DATA_NUM )  + __i ) ] =  ( x1[ (  ( 4 * __DATA_NUM )  + __i ) ].add( ( k1[ (  ( 4 * __DATA_NUM )  + __i ) ].multiply(d, MathContext.DECIMAL128) ) ) ) ;
			x2[ (  ( 5 * __DATA_NUM )  + __i ) ] =  ( x1[ (  ( 5 * __DATA_NUM )  + __i ) ].add( ( k1[ (  ( 5 * __DATA_NUM )  + __i ) ].multiply(d, MathContext.DECIMAL128) ) ) ) ;
			x2[ (  ( 6 * __DATA_NUM )  + __i ) ] =  ( x1[ (  ( 6 * __DATA_NUM )  + __i ) ].add( ( k1[ (  ( 6 * __DATA_NUM )  + __i ) ].multiply(d, MathContext.DECIMAL128) ) ) ) ;
			x2[ (  ( 7 * __DATA_NUM )  + __i ) ] =  ( x1[ (  ( 7 * __DATA_NUM )  + __i ) ].add( ( k1[ (  ( 7 * __DATA_NUM )  + __i ) ].multiply(d, MathContext.DECIMAL128) ) ) ) ;
			xo[ (  ( 0 * __DATA_NUM )  + __i ) ] = x2[ (  ( 0 * __DATA_NUM )  + __i ) ];
			xo[ (  ( 1 * __DATA_NUM )  + __i ) ] = x2[ (  ( 1 * __DATA_NUM )  + __i ) ];
			xo[ (  ( 2 * __DATA_NUM )  + __i ) ] = x2[ (  ( 2 * __DATA_NUM )  + __i ) ];
			xo[ (  ( 3 * __DATA_NUM )  + __i ) ] = x2[ (  ( 3 * __DATA_NUM )  + __i ) ];
			xo[ (  ( 4 * __DATA_NUM )  + __i ) ] = x2[ (  ( 4 * __DATA_NUM )  + __i ) ];
			xo[ (  ( 5 * __DATA_NUM )  + __i ) ] = x2[ (  ( 5 * __DATA_NUM )  + __i ) ];
			xo[ (  ( 6 * __DATA_NUM )  + __i ) ] = x2[ (  ( 6 * __DATA_NUM )  + __i ) ];
			xo[ (  ( 7 * __DATA_NUM )  + __i ) ] = x2[ (  ( 7 * __DATA_NUM )  + __i ) ];
			xi[ (  ( 0 * __DATA_NUM )  + __i ) ] = xo[ (  ( 0 * __DATA_NUM )  + __i ) ];
			xi[ (  ( 1 * __DATA_NUM )  + __i ) ] = xo[ (  ( 1 * __DATA_NUM )  + __i ) ];
			xi[ (  ( 2 * __DATA_NUM )  + __i ) ] = xo[ (  ( 2 * __DATA_NUM )  + __i ) ];
			xi[ (  ( 3 * __DATA_NUM )  + __i ) ] = xo[ (  ( 3 * __DATA_NUM )  + __i ) ];
			xi[ (  ( 4 * __DATA_NUM )  + __i ) ] = xo[ (  ( 4 * __DATA_NUM )  + __i ) ];
			xi[ (  ( 5 * __DATA_NUM )  + __i ) ] = xo[ (  ( 5 * __DATA_NUM )  + __i ) ];
			xi[ (  ( 6 * __DATA_NUM )  + __i ) ] = xo[ (  ( 6 * __DATA_NUM )  + __i ) ];
			xi[ (  ( 7 * __DATA_NUM )  + __i ) ] = xo[ (  ( 7 * __DATA_NUM )  + __i ) ];

		}


	}

}


/**
* Compute x^exponent to a given scale.  Uses the same
* algorithm as class numbercruncher.mathutils.IntPower.
* @param x the value x
* @param exponent the exponent value
* @param scale the desired scale of the result
* @return the result value
*/
public static BigDecimal intPower(BigDecimal x, long exponent,int scale)
{
   if (exponent < 0) {
      return BigDecimal.valueOf(1).divide(intPower(x, -exponent, scale), scale,BigDecimal.ROUND_HALF_EVEN);
   }

   BigDecimal power = BigDecimal.valueOf(1);
   // Loop to compute value^exponent.
   while (exponent > 0) {
       // Is the rightmost bit a 1?
       if ((exponent & 1) == 1) {
           power = power.multiply(x).setScale(scale, BigDecimal.ROUND_HALF_EVEN);
       }

       // Square x and shift exponent 1 bit to the right.
	x = x.multiply(x).setScale(scale, BigDecimal.ROUND_HALF_EVEN);
       exponent >>= 1;

       Thread.yield();
   }

   return power;
}
/**
 * Compute the integral root of x to a given scale, x >= 0.
 * Use Newton's algorithm.
 * @param x the value of x
 * @param index the integral root value
 * @param scale the desired scale of the result
 * @return the result value
 */
public static BigDecimal intRoot(BigDecimal x, long index,int scale)
{
   // Check that x >= 0.
   if (x.signum() < 0) {
       throw new IllegalArgumentException("x < 0");
   }
   int        sp1 = scale + 1;
   BigDecimal n   = x;
   BigDecimal i   = BigDecimal.valueOf(index);
   BigDecimal im1 = BigDecimal.valueOf(index-1);
   BigDecimal tolerance = BigDecimal.valueOf(5).movePointLeft(sp1);
   BigDecimal xPrev;
   // The initial approximation is x/index.
   x = x.divide(i, scale, BigDecimal.ROUND_HALF_EVEN);
   // Loop until the approximations converge
   // (two successive approximations are equal after rounding).
   do {
       // x^(index-1)
       BigDecimal xToIm1 = intPower(x, index-1, sp1);
       // x^index
       BigDecimal xToI = x.multiply(xToIm1).setScale(sp1, BigDecimal.ROUND_HALF_EVEN);
       // n + (index-1)*(x^index)
       BigDecimal numerator = n.add(im1.multiply(xToI)).setScale(sp1, BigDecimal.ROUND_HALF_EVEN);
       // (index*(x^(index-1))
       BigDecimal denominator = i.multiply(xToIm1).setScale(sp1, BigDecimal.ROUND_HALF_EVEN);

       // x = (n + (index-1)*(x^index)) / (index*(x^(index-1)))
       xPrev = x;
       x = numerator.divide(denominator, sp1, BigDecimal.ROUND_DOWN);

       Thread.yield();
   } while (x.subtract(xPrev).abs().compareTo(tolerance) > 0);
   return x;
}

/**
 * Compute e^x to a given scale.
 * Break x into its whole and fraction parts and
 * compute (e^(1 + fraction/whole))^whole using Taylor's formula.
 * @param x the value of x
 * @param scale the desired scale of the result
 * @return the result value
 */
public static BigDecimal exp(BigDecimal x, int scale)
{
   // e^0 = 1
   if (x.signum() == 0) {
       return BigDecimal.valueOf(1);
   }
   // If x is negative, return 1/(e^-x).
   else if (x.signum() == -1) {
       return BigDecimal.valueOf(1).divide(exp(x.negate(), scale), scale,BigDecimal.ROUND_HALF_EVEN);
   }

   // Compute the whole part of x.
   BigDecimal xWhole = x.setScale(0, BigDecimal.ROUND_DOWN);

   // If there isn't a whole part, compute and return e^x.
   if (xWhole.signum() == 0) return expTaylor(x, scale);

   // Compute the fraction part of x.
   BigDecimal xFraction = x.subtract(xWhole);

   // z = 1 + fraction/whole
   BigDecimal z = BigDecimal.valueOf(1).add(xFraction.divide(
                               xWhole, scale,
                               BigDecimal.ROUND_HALF_EVEN));

   // t = e^z
   BigDecimal t = expTaylor(z, scale);

   BigDecimal maxLong = BigDecimal.valueOf(Long.MAX_VALUE);
   BigDecimal result  = BigDecimal.valueOf(1);

   // Compute and return t^whole using intPower().
   // If whole > Long.MAX_VALUE, then first compute products
   // of e^Long.MAX_VALUE.
   while (xWhole.compareTo(maxLong) >= 0) {
       result = result.multiply(
                           intPower(t, Long.MAX_VALUE, scale))
                   .setScale(scale, BigDecimal.ROUND_HALF_EVEN);
       xWhole = xWhole.subtract(maxLong);

       Thread.yield();
   }
   return result.multiply(intPower(t, xWhole.longValue(), scale))
                   .setScale(scale, BigDecimal.ROUND_HALF_EVEN);
}

/**
 * Compute e^x to a given scale by the Taylor series.
 * @param x the value of x
 * @param scale the desired scale of the result
 * @return the result value
 */
private static BigDecimal expTaylor(BigDecimal x, int scale)
{
   BigDecimal factorial = BigDecimal.valueOf(1);
   BigDecimal xPower    = x;
   BigDecimal sumPrev;

   // 1 + x
   BigDecimal sum  = x.add(BigDecimal.valueOf(1));

   // Loop until the sums converge
   // (two successive sums are equal after rounding).
   int i = 2;
   do {
       // x^i
       xPower = xPower.multiply(x)
                   .setScale(scale, BigDecimal.ROUND_HALF_EVEN);

       // i!
       factorial = factorial.multiply(BigDecimal.valueOf(i));

       // x^i/i!
       BigDecimal term = xPower
                           .divide(factorial, scale,
                                   BigDecimal.ROUND_HALF_EVEN);

       // sum = sum + x^i/i!
       sumPrev = sum;
       sum = sum.add(term);

       ++i;
       Thread.yield();
   } while (sum.compareTo(sumPrev) != 0);

   return sum;
}

/**
 * Compute the natural logarithm of x to a given scale, x > 0.
 */
public static BigDecimal ln(BigDecimal x, int scale)
{
   // Check that x > 0.
   if (x.signum() <= 0) {
       throw new IllegalArgumentException("x <= 0");
   }

   // The number of digits to the left of the decimal point.
   int magnitude = x.toString().length() - x.scale() - 1;

   if (magnitude < 3) {
       return lnNewton(x, scale);
   }

   // Compute magnitude*ln(x^(1/magnitude)).
   else {

       // x^(1/magnitude)
       BigDecimal root = intRoot(x, magnitude, scale);

       // ln(x^(1/magnitude))
       BigDecimal lnRoot = lnNewton(root, scale);

       // magnitude*ln(x^(1/magnitude))
       return BigDecimal.valueOf(magnitude).multiply(lnRoot)
                   .setScale(scale, BigDecimal.ROUND_HALF_EVEN);
   }
}

/**
 * Compute the natural logarithm of x to a given scale, x > 0.
 * Use Newton's algorithm.
 */
private static BigDecimal lnNewton(BigDecimal x, int scale)
{
   int        sp1 = scale + 1;
   BigDecimal n   = x;
   BigDecimal term;

   // Convergence tolerance = 5*(10^-(scale+1))
   BigDecimal tolerance = BigDecimal.valueOf(5)
                                       .movePointLeft(sp1);

   // Loop until the approximations converge
   // (two successive approximations are within the tolerance).
   do {

       // e^x
       BigDecimal eToX = exp(x, sp1);

       // (e^x - n)/e^x
       term = eToX.subtract(n)
                   .divide(eToX, sp1, BigDecimal.ROUND_DOWN);

       // x - (e^x - n)/e^x
       x = x.subtract(term);

       Thread.yield();
   } while (term.compareTo(tolerance) > 0);

   return x.setScale(scale, BigDecimal.ROUND_HALF_EVEN);
}

/**
 * Compute the arctangent of x to a given scale, |x| < 1
 * @param x the value of x
 * @param scale the desired scale of the result
 * @return the result value
 */
public static BigDecimal arctan(BigDecimal x, int scale)
{
   // Check that |x| < 1.
   if (x.abs().compareTo(BigDecimal.valueOf(1)) >= 0) {
       throw new IllegalArgumentException("|x| >= 1");
   }

   // If x is negative, return -arctan(-x).
   if (x.signum() == -1) {
       return arctan(x.negate(), scale).negate();
   }
   else {
       return arctanTaylor(x, scale);
   }
}

/**
 * Compute the arctangent of x to a given scale
 * by the Taylor series, |x| < 1 
 * @param x the value of x
 * @param scale the desired scale of the result
 * @return the result value 
 */
private static BigDecimal arctanTaylor(BigDecimal x, int scale)
{
   int     sp1     = scale + 1;
   int     i       = 3;
   boolean addFlag = false;

   BigDecimal power = x;
   BigDecimal sum   = x;
   BigDecimal term;

   // Convergence tolerance = 5*(10^-(scale+1))
   BigDecimal tolerance = BigDecimal.valueOf(5)
                                       .movePointLeft(sp1);

   // Loop until the approximations converge
   // (two successive approximations are within the tolerance).
   do {
       // x^i
       power = power.multiply(x).multiply(x)
                   .setScale(sp1, BigDecimal.ROUND_HALF_EVEN);

       // (x^i)/i
       term = power.divide(BigDecimal.valueOf(i), sp1,
                            BigDecimal.ROUND_HALF_EVEN);

       // sum = sum +- (x^i)/i
       sum = addFlag ? sum.add(term)
                     : sum.subtract(term);

       i += 2;
       addFlag = !addFlag;

       Thread.yield();
   } while (term.compareTo(tolerance) > 0);

   return sum;
}

/**
 * Compute the square root of x to a given scale, x >= 0.
 * Use Newton's algorithm.
 * @param x the value of x
 * @param scale the desired scale of the result2
 * @return the result value
 */
public static BigDecimal sqrt(BigDecimal x, int scale)
{
   // Check that x >= 0.
   if (x.signum() < 0) {
       throw new IllegalArgumentException("x < 0");
   }

   // n = x*(10^(2*scale))
   BigInteger n = x.movePointRight(scale << 1).toBigInteger();

  // The first approximation is the upper half of n.
   int bits = (n.bitLength() + 1) >> 1;
   BigInteger ix = n.shiftRight(bits);
   BigInteger ixPrev;

   // Loop until the approximations converge
   // (two successive approximations are equal after rounding).
   do {
       ixPrev = ix;

       // x = (x + n/x)/2
       ix = ix.add(n.divide(ix)).shiftRight(1);

       Thread.yield();
   } while (ix.compareTo(ixPrev) != 0);

   return new BigDecimal(ix, scale);
}
}

